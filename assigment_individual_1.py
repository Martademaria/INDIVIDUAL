# -*- coding: utf-8 -*-
"""ASSIGMENT_INDIVIDUAL_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-3cbUg4GyoiwwNkKYnpaHLbAbcvQcU-k
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

breast_df = pd.read_csv("breast_cancer.csv")

breast_df.head(10)

breast_df.tail()

breast_df.describe()

breast_df.info()

breast_df = breast_df.drop(columns='id')

benign = breast_df[breast_df['diagnosis'] == 'B']

malign = breast_df[breast_df['diagnosis'] == 'M']

benign

malign

print( 'Benign breast cancer percentage =', (len(benign) / len(breast_df) )*100,"%")

print( 'Malign breast cancer percentage =', (len(malign) / len(breast_df) )*100,"%")

column_headers = breast_df.columns.values

# kernel density estimation (KDE) is a non-parametric way to estimate the probability density function of a random variable.
i = 1

fig, ax = plt.subplots(8,4,figsize=(18,30))
for column_header in column_headers:
    # Check if the column contains numerical data before plotting
    if pd.api.types.is_numeric_dtype(benign[column_header]):
        plt.subplot(8,4,i)
        sns.kdeplot(benign[column_header], bw = 0.4, label = "Bening", shade=True, color="r", linestyle="--")
        sns.kdeplot(malign[column_header], bw = 0.4, label = "Malign", shade=True, color= "y", linestyle=":")
        plt.title(column_header, fontsize=12)
        i = i + 1
plt.show();

X = breast_df.drop(['diagnosis'],axis=1)

y = breast_df['diagnosis']

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state=5)

from sklearn.naive_bayes import GaussianNB
NB_classifier = GaussianNB()
NB_classifier.fit(X_train, y_train)

from sklearn.metrics import classification_report, confusion_matrix

y_predict_train = NB_classifier.predict(X_train)
y_predict_train
cm = confusion_matrix(y_train, y_predict_train)
sns.heatmap(cm, annot=True)

# Predicting the Test set results
y_predict_test = NB_classifier.predict(X_test)
cm = confusion_matrix(y_test, y_predict_test)
sns.heatmap(cm, annot=True)

print(classification_report(y_test, y_predict_test))

"""IMPROVING MODEL"""

min_train = X_train.min()
min_train

range_train = (X_train - min_train).max()
range_train

X_train_scaled = (X_train - min_train)/range_train

X_train_scaled

min_test = X_test.min()
range_test = (X_test - min_test).max()
X_test_scaled = (X_test - min_test)/range_test

NB_classifier = GaussianNB()
NB_classifier.fit(X_train_scaled, y_train)
y_predict = NB_classifier.predict(X_test_scaled)
cm = confusion_matrix(y_test, y_predict)
sns.heatmap(cm, annot=True)

print(classification_report(y_test, y_predict))

# Convert 'B' and 'M' values to numerical representations (e.g., 0 and 1) before using sum().
# Assuming 'B' represents benign (0) and 'M' represents malignant (1)
y_test_numeric = y_test.map({'B': 0, 'M': 1})

print("Number of bening cancers in the testing dataset = ", sum(y_test_numeric))